***服务端采用select多路复用，监听listenfd和client***

```c
    for ( ; ; ) {
        rset = masterset;
        if ((nready = select(maxfd + 1, &rset, NULL, NULL, NULL)) < 0)
            err_sys("select error");

        if (FD_ISSET(listenfd, &rset)) {   /* 有新的连接到来 */
            clilen = sizeof(cliaddr);
            if ((connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &clilen)) < 0)
                err_sys("accept error");

            for (i = 0; i < MAXCLIENT; i++)
                if (client[i] < 0)
                    break;
            if (i >= MAXCLIENT)
                err_quit("too many clients");
            client[i] = connfd;

            FD_SET(connfd, &masterset);
            maxfd = max(maxfd, connfd);
        }

        for (i = 0; i < nready; i++) {   /* 某个client可读 */
            if (FD_ISSET(client[i], &rset)) {
                ;
            }
        }
    }
```
***服务端主线程select轮询，用一个线程池执行任务。每当一个任务到来时，就调用对应的回调函数，并将其加入到任务队列中。***

```c
typedef struct task {
    void *(*proc_handler)(void *);   /* 执行任务的回调函数 */
    void *arg;
    struct task *next;
} task_t;

typedef struct {
    pthread_mutex_t q_lock;
    pthread_cond_t q_ready;
    pthread_t *ptid;
    task_t *q_head;     /* 任务队列 */
    int q_tasks;        /* 任务数 */
    int nthreads;       /* 线程数 */
    int destroy;
} pool_t;

void *(*call_func[])(void *) = {
    do_register,
    do_login,
    do_add_friend,
    do_del_friend,
    do_priv_chat,
    do_group_chat,
};
```
***线程池使用pthread互斥量和条件变量加锁，pool_init进行必要的初始化，pool_add_task添加任务，pool_destroy销毁池子，
thread_doit执行任务。***

```c
static pool_t *pool;

void *
thread_doit(void *arg)
{
    for ( ; ; ) {
        pthread_mutex_lock(&pool->q_lock);
        while (!pool->destroy && pool->q_tasks == 0)
            /* 睡眠在q_ready上，等待其为真 */
            pthread_cond_wait(&pool->q_ready, &pool->q_lock);

        if (pool->destroy) {
            pthread_mutex_unlock(&pool->q_lock);
            pthread_exit(NULL);
        }

        /* 取下任务队列的头节点 */
        pool->q_tasks--;
        task_t *cur_task = pool->q_head;
        pool->q_head = pool->q_head->next;
        pthread_mutex_unlock(&pool->q_lock);

        (cur_task->proc_handler)(cur_task->arg);
        free(cur_task);
    }
    return 0;
}

void
pool_init(int nthreads)
{
    assert(pool = malloc(sizeof(pool_t)));
    pthread_mutex_init(&pool->q_lock, NULL);
    pthread_cond_init(&pool->q_ready, NULL);
    assert(pool->ptid = calloc(nthreads, sizeof(pthread_t)));
    pool->q_head = NULL;
    pool->nthreads = nthreads;
    pool->q_tasks = 0;
    pool->destroy = 0;

    for (int i = 0; i < nthreads; i++)
        pthread_create(&pool->ptid[i], NULL, thread_doit, NULL);
}

void
pool_add_task(void *(*proc_handler)(void *arg), void *arg)
{
    task_t *ptask;

    assert(ptask = malloc(sizeof(task_t)));
    ptask->proc_handler = proc_handler;
    ptask->arg = arg;

    pthread_mutex_lock(&pool->q_lock);
    ptask->next = pool->q_head;
    pool->q_head = ptask;
    pool->q_tasks++;
    pthread_mutex_unlock(&pool->q_lock);

    /* 唤醒一个线程 */
    pthread_cond_signal(&pool->q_ready);
}

void
pool_destroy(void)
{
    /* 避免重复销毁 */
    if (pool->destroy)
        return;
    pool->destroy = 1;

    pthread_cond_broadcast(&pool->q_ready);

    for (int i = 0; i < pool->nthreads; i++)
        pthread_join(pool->ptid[i], NULL);
    free(pool->ptid);

    while (pool->q_head) {
        task_t *tmp = pool->q_head->next;
        free(pool->q_head);
        pool->q_head = tmp;
    }
    pthread_mutex_destroy(&pool->q_lock);
    pthread_cond_destroy(&pool->q_ready);

    free(pool);
    pool = NULL;
}
```
***消息通讯采用[UNP]上的两个函数，保证包接收和发送的完整***

```c
ssize_t 
readn(int fd, void *vptr, size_t nsize)
{
    size_t      nleft, n;
    ssize_t     nread;
    char        *ptr;

    if (n > nsize)
        n = nsize;
    nleft =  n;
    ptr = vptr;
    while (nleft > 0) {
        if ((nread = read(fd, ptr, nleft)) < 0) {
            if (errno == EINTR)
                nread = 0;   /*  中断后重启read  */
            else
                return -1;
        } else if (nread == 0)
            break;
        nleft -= nread;
        ptr += nread;
    }
    return n - nleft;
}

ssize_t 
writen(int fd, const void *vptr, size_t nsize)
{
    size_t      nleft;
    ssize_t     nwritten;
    const char  *ptr;

    ptr = vptr;
    nleft = nsize;
    while (nleft > 0) {
        if ((nwritten = write(fd, ptr, nleft)) <= 0) {
            if (nwritten < 0 && errno == EINTR)
                nwritten = 0;
            else
                return -1;
        }
        nleft -= nwritten;
        ptr += nwritten;
    }
    return nsize;
}
```

***方便起见，将所有数据存入数据库，使用mysql。***

***客户端采用双线程，一个用于监听stdin，一个用于socket。***

```c
pthread_create(&tid[0], NULL, listen_stdio, (void *)&connfd);
pthread_create(&tid[1], NULL, listen_socket, (void *)&connfd);

void *
listen_stdio(void *arg)
{
    char    buf[BUFSIZE];
    int     sockfd = *(int *)arg;

    while (fgets(buf, sizeof(buf), stdin) && !feof(stdin)) {
        parse_line(sockfd, buf);
    }
    return 0;
}

void *
listen_socket(void *arg)
{
    int     n;
    char    buf[BUFSIZE];
    int     sockfd = *(int *)arg;

again:
    while ((n = read(sockfd, buf, sizeof(buf))) > 0)
        write(1, buf, strlen(buf));
    if (n < 0 && errno == EINTR)
        goto again;
    else if (n < 0)
        err_sys("read error");
    return 0;
}
```

***采用统一的错误处理。err_sys打印对应的errno并终止程序；err_quit不打印errno；err_msg只输出一条错误消息***

```c
void 
err_sys(const char *fmt, ...)
{
    va_list ap;
    char    buf[BUFSIZ];

    va_start(ap, fmt);
    vsnprintf(buf, BUFSIZ - 1, fmt, ap);
    snprintf(buf + strlen(buf), BUFSIZ - strlen(buf) - 1,
            ": %s\n", strerror(errno));
    fputs(buf, stderr);
    va_end(ap);
    exit(1);
}

void 
err_quit(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    exit(1);
}

void 
err_msg(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
    va_end(ap);
}
```
